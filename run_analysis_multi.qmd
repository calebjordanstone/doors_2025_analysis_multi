---
title: "Honours Analysis 2025 - Multi"
format: html
embed-resources: true
editor: visual
execute-dir: project
---

```{r}
#| output: false

# load libraries
library(afex)
library(emmeans)
library(data.table)
library(ggpubr)
library(tidyverse)
library(stringr)

# set emmeans option to multivariate
afex_options(emmeans_model = "multivariate") # use multivariate for RM designs
```

# Multi-tasking experiment

```{r}
# assign experiment label
exp <- 'multi'

# load data
avg_multi <- fread('data/exp-multi_avg.csv')
avg_multi_mts <- fread('data/exp-multi_mts_avg.csv')

```

## Testing session

```{r}
# assign session label
ses <- 'test'

# change factor level names
avg_multi[, switch := ifelse(switch==0, 'non-switch', 'switch')]
avg_multi[, train_type := ifelse(train_type==1,'stable', 'variable')]
avg_multi[, ses := ifelse(ses==2, 'training', 'testing')]

## define contrasts for analysis - note I create the emm tables in the relevant code chunk for each DV 

## main effects
# main effect of train type
b <- list(
  stable_varaible = rep(c(1/6, -1/6), each=6)
)
# main effect of multi_trial
w1 <- list(
  first_sub = rep(c(1/6, -1/6, 1/6, -1/6), each=3)
)
# compare levels of multi_cond
w2 <- list(
  neither_none = rep(c(1/4, -1/4, 0), times=4),
  neither_other = rep(c(1/4, 0, -1/4), times=4),
  none_other = rep(c(0, 1/4, -1/4), times=4)
)

## interaction effects - I had a go at specifying what these would be, though I remember you saying that the interaction contrasts are no longer orthogonal, so not sure if I've done these right

# multipy coefficients by 6 so they sum back to 1
b_w1_int <- list(
  ttype_by_mtrial = (b$stable_varaible*w1$first_sub)*6 
)
b_w2_int <- list(
  ttype_by_mcond_1 = (b$stable_varaible*w2$neither_none)*6, 
  ttype_by_mcond_2 = (b$stable_varaible*w2$neither_other)*6,
  ttype_by_mcond_3 = (b$stable_varaible*w2$none_other)*6
)
w1_w2_int <- list(
  mtrial_by_mcond_1 = (w1$first_sub*w2$neither_none)*6,
  mtrial_by_mcond_2 = (w1$first_sub*w2$neither_other)*6,
  mtrial_by_mcond_3 = (w1$first_sub*w2$none_other)*6
)
# multipy coefficients by 6*6 so they sum back to 1
b_w1_w2_int <- list(
  b_w1_w2_1 = (b$stable_varaible*w1$first_sub*w2$neither_none)*36,
  b_w1_w2_2 = (b$stable_varaible*w1$first_sub*w2$neither_other)*36,
  b_w1_w2_3 = (b$stable_varaible*w1$first_sub*w2$none_other)*36
)

## post-hoc contrasts 
# can use the below to create contrasts to look at simple effects?
b_levels = list(
  stable = rep(c(1, 0), each=6),
  variable = rep(c(0, 1), each=6)
)
w1_levels = list(
  first = rep(c(1, 0, 1, 0), each=3),
  last = rep(c(0, 1, 0, 1), each=3)
)
w2_levels = list(
  neither = rep(c(1, 0, 0), times=4),
  none = rep(c(0, 1, 0), times=4),
  other = rep(c(0, 0, 1), times=4)
)

# e.g., Effect of multi_cond might be present on first but not subsequent trials. (Might be better to locate these contrasts in the relevant code chunk, rather than at the top with the generic ones)
w1_w2_simp = list(
  mcond_1_at_mtrial_1 = (w2$neither_none*w1_levels$first)*2,
  mcond_2_at_mtrial_1 = (w2$neither_other*w1_levels$first)*2,
  mcond_3_at_mtrial_1 = (w2$none_other*w1_levels$first)*2,
  mcond_1_at_mtrial_2 = (w2$neither_none*w1_levels$last)*2,
  mcond_2_at_mtrial_2 = (w2$neither_other*w1_levels$last)*2,
  mcond_3_at_mtrial_2 = (w2$none_other*w1_levels$last)*2
)

# same as above but also including train_type
b_w1_w2_simp = list(
  w2_1_at_w1_1_at_b_1 = (w2$neither_none*w1_levels$first*b_levels$stable)*4,
  w2_2_at_w1_1_at_b_1 = (w2$neither_other*w1_levels$first*b_levels$stable)*4,
  w2_3_at_w1_1_at_b_1 = (w2$none_other*w1_levels$first*b_levels$stable)*4,
  w2_1_at_w1_2_at_b_1 = (w2$neither_none*w1_levels$last*b_levels$stable)*4,
  w2_2_at_w1_2_at_b_1 = (w2$neither_other*w1_levels$last*b_levels$stable)*4,
  w2_3_at_w1_2_at_b_1 = (w2$none_other*w1_levels$last*b_levels$stable)*4,
  w2_1_at_w1_1_at_b_2 = (w2$neither_none*w1_levels$first*b_levels$variable)*4,
  w2_2_at_w1_1_at_b_2 = (w2$neither_other*w1_levels$first*b_levels$variable)*4,
  w2_3_at_w1_1_at_b_2 = (w2$none_other*w1_levels$first*b_levels$variable)*4,
  w2_1_at_w1_2_at_b_2 = (w2$neither_none*w1_levels$last*b_levels$variable)*4,
  w2_2_at_w1_2_at_b_2 = (w2$neither_other*w1_levels$last*b_levels$variable)*4,
  w2_3_at_w1_2_at_b_2 = (w2$none_other*w1_levels$last*b_levels$variable)*4
)

```

#### Defining contrasts of interest

Here I define a set of contrasts according to the following procedure/principles:

1.  We have pre-defined hypotheses about specific differences we are interested in
2.  We have collected data using a factorial ANOVA design
3.  Because of #1, we can define a priori contrast vectors we are interested in testing
4.  Because of #2, we can determine that contrast vectors that are orthogonal to each other constitute independent tests. Those that are not orthogonal to each other constitute dependent tests. Thus we group our contrasts into sets. Within a set, contrasts should be non-orthogonal. Across sets, they should be orthogonal. This creates our families of tests.
5.  Each family should be controlled at $\alpha$ = .05. If there is only one contrast in the family, then the effect is tested at p=.05. If there is more than one contrast in the family, then we apply a Bonferonni correction to the tests (as the family is a priori defined).

```{r}

# adapting the code above to test the key hypotheses of the study. Under each section of comments, I have built up to the contrast that tests the hypothesis of interest. Then I test for orthogonality, to guide how to control the error rate during hypothesis testing.

ngrps <- 2
n_multi <- 3 # levels of multitasking
n_trial_type <- 2 # levels of search trial type (first vs subsequent)

##### apriori (to apply bonferroni correction on orthogonal sets of contrasts)
# first, we hypothesise that performance should be different on the neither/other trials compared to the none trials, for the first of the search trials
multi_vs_sing_first <- rep(c(1/2, -1, 1/2, 0, 0, 0), times=ngrps)

# next, we hypothesise that the performance difference on other trials should be worse than on neither trials, for the first of the search trials.
multi_neither_vs_other <- rep(c(1, 0, -1, 0, 0, 0), times=ngrps)

# next we predict that this difference on other vs neither trials should be worse for the variable group, compared to the stable group, as the latter group should suffer less cross-task interference 
group <- rep(c(-1, 1), each=n_multi*n_trial_type)
group_by_multi_neither_vs_other <- multi_neither_vs_other * group

# next, we want to know, is the difference between neither/other trials vs none trials, different for first, compared to subsequent search trials? i.e. we predict that the impact of multitasking should reduce from the first to subsequent search trials
first_vs_subs <- rep(c(1, 1, 1, -1, -1, -1), times=ngrps)
multi_vs_sing_both <- rep(c(1/2, -1, 1/2), times=ngrps*n_trial_type)
first_vs_subs_by_multi_vs_sing <- first_vs_subs * multi_vs_sing_both 

# next, we want to know, is the difference between neither than other different for first to subsequent search trials. We predict that any difference should reduce
multi_neither_vs_other_full <- c(1, 0, -1, 1, 0, -1)
first_vs_subs_by_neither_vs_other <- first_vs_subs * multi_neither_vs_other_full

# last, we predict that both of the above effects should be smaller for the variable group compared to the stable group
group_by_first_vs_subs_by_multi_vs_sing <- group * first_vs_subs_by_multi_vs_sing
group_by_first_vs_subs_by_neither_vs_other <- group * first_vs_subs_by_neither_vs_other

# now we have our key contrasts, we can check if they are orthogonal.
# first, I turn them into a matrix
n_contrasts <- 7
all_contrasts <- matrix(c(multi_vs_sing_first, # 1
                          multi_neither_vs_other, # 2
                          group_by_multi_neither_vs_other, # 3 
                          first_vs_subs_by_multi_vs_sing, # 4
                          first_vs_subs_by_neither_vs_other, # 5
                          group_by_first_vs_subs_by_multi_vs_sing, # 6
                          group_by_first_vs_subs_by_neither_vs_other), byrow=FALSE, ncol=n_contrasts)
# compute the gram matrix (i.e. the dot product between all pairs of vectors)
G <- t(all_contrasts) %*% all_contrasts # note that if the vectors are all orthogonal, then the off diagonal enties will be zero, any non-orthognal contrasts will have an off-diagonal element that is different to zero
G # look at G
# I can see that contrasts 1 & 4 are correlated (non-orthogonal) so bonferroni adjustment needs to be applied to these two together, when testing the contrast. 
# 2 & 5 are also non-orthogonal
# 3 & 7 are also non-orthogonal
# The rest are independent to the others so can each be tested at p<.05. So lets define the families now
# I am making the families manually. One day, dream coder Kelly or Caleb will automate this based on the indexes of the off-diagonal elements > 0 :)
fam_multi_vs_sing_first <- list(multi_vs_sing_first = multi_vs_sing_first, # 1
                               first_vs_subs_by_multi_vs_sing = first_vs_subs_by_multi_vs_sing) # 4
                                   
fam_multi_neither_vs_other <- list(multi_neither_vs_other = multi_neither_vs_other, #2
                                   first_vs_subs_by_neither_vs_other = first_vs_subs_by_neither_vs_other) #5

fam_group_w_one_within <- list(group_by_multi_neither_vs_other = group_by_multi_neither_vs_other, # 3
                                           group_by_first_vs_subs_by_neither_vs_other = group_by_first_vs_subs_by_neither_vs_other) # 7

fam_group_by_first_vs_subs_by_multi_vs_sing <- list(group_by_first_vs_subs_by_multi_vs_sing=group_by_first_vs_subs_by_multi_vs_sing) # 6

# note that any tests beyond this point will be post-hoc simple effect comparisons, will be non-orthognal. After each of the above contrast tests, we should determine any post-hoc tests we want to do, which will determine how we control for them.


```

### Accuracy

Here we apply the above defined contrasts to the accuracy data

```{r}

# assign variable label
var <- 'accuracy'

# specify model
mdl <- aov_ez(id = 'sub',
              within = c('multi_cond', 'multi_trial'), 
              between = 'train_type',
              dv = 'accuracy_mean',
              data = avg_multi[ses=='testing'])

# get estimated marginal means from the model
emm_int <- emmeans(mdl, c('multi_cond', 'multi_trial', 'train_type'))

# inspect means
emm_int

```

Now compute contrasts for each family

First, the family that cares about whether accuracy was lower on multitask compared to single task trials, for the first of the search trials, and whether this multitasking cost reduced when moving from the first to subsequent search trials.

```{r}

## compute contrasts for each family
cntrsts_fam_multi_vs_sing_first <- contrast(emm_int, fam_multi_vs_sing_first, adjust='bonferroni')

cntrsts_fam_multi_vs_sing_first
```

So now we know that accuracy was significantly lower on multitask compared to single task trials for the first of the search trials, and that this difference reduced from first to subsequent search trials. Neat!

Now for the family that cares about whether neither and other trials are different from each other...

```{r}

cntrsts_fam_multi_neither_vs_other <- contrast(emm_int, fam_multi_neither_vs_other, adjust='bonferroni')
cntrsts_fam_multi_neither_vs_other
```

Resounding no on those.

Now we look at the family which cares about the interaction of group with one within subjects factor - either the multi vs single, or neither vs other -

```{r}

cntrst_fam_group_w_one_within <- contrast(emm_int, fam_group_w_one_within, adjust='bonferroni')
cntrst_fam_group_w_one_within

```

Also a resounding no.

And last, we look at our last interaction of interest - the group x multi_vs_sing x first_vs_subs

```{r}

cntrsts_fam_group_by_first_vs_subs_by_multi_vs_sing <- contrast(emm_int, fam_group_by_first_vs_subs_by_multi_vs_sing, adjust='bonferroni')
cntrsts_fam_group_by_first_vs_subs_by_multi_vs_sing
```

Also a resounding no :)

Now I write a function that automatically applies these contrast families to a table of emms, given you have the list of families and the dv -

```{r}

# a function to rule them all
list_of_contrast_lists <- list(fam_multi_vs_sing_first, 
                               fam_multi_neither_vs_other,
                               fam_group_w_one_within,
                               fam_group_by_first_vs_subs_by_multi_vs_sing)

get_all_contrsts <- function(this_dv, list_of_contrast_lists){
  
  # specify model
  mdl <- aov_ez(id = 'sub',
                within = c('multi_cond', 'multi_trial'), 
                between = 'train_type',
                dv = this_dv,
                data = avg_multi[ses=='testing'])
  emm_int <- emmeans(mdl, c('multi_cond', 'multi_trial', 'train_type'))
  do.call(rbind, lapply(list_of_contrast_lists, function(x) summary(contrast(emm_int, x, adjust='bonferroni'))))
}

```

### Accuracy

```{r}
# assign variable label
var <- 'accuracy'

# specify model
mdl <- aov_ez(id = 'sub',
              within = c('multi_cond', 'multi_trial'), 
              between = 'train_type',
              dv = 'accuracy_mean',
              data = avg_multi[ses=='testing'])

# get estimated marginal means from the model
emm_int <- emmeans(mdl, c('multi_cond', 'multi_trial', 'train_type'))

# inspect means
emm_int

## compute contrasts for each family
## within subject contrasts
(cw1 <- contrast(emm_int, c(w1, w2, w1_w2_int), adjust='bonferroni')) 

## between subject contrasts
(cb <- contrast(emm_int, b))

## between x within contrasts
(cbw1w2 <- contrast(emm_int, b_w1_w2_int, adjust='bonferroni'))

## two different ways of testing for the multi_trial vs multi_cond interaction - not sure which is best?
(cw1w2 <- contrast(emm_int, w1_w2_int, adjust='bonferroni')) # this one tests whether the difference between the 3 combinations of multi_cond levels is significantly different between multi_trial levels (i.e., 3 tests)


(cbw1w2 <- contrast(emm_int, b_w1_w2_simp, adjust='bonferroni'))

# plot result
afex_plot(mdl, 
          x = 'multi_cond', 
          trace = 'train_type', 
          panel = 'multi_trial',
          error = "within", 
          data_plot = F) + 
  theme_pubclean()

# save result
dt <- as.data.table(rbind(data.frame(cw1), 
                          data.frame(cw2), 
                          data.frame(cb))) # add new rows as necessary 
dt[, names(.SD) := lapply(.SD, round, 2), .SDcols=c('estimate', 'SE', 'df', 't.ratio')
][, names(.SD) := lapply(.SD, round, 3), .SDcols=c('p.value')]
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(dt, fln)
```

### Setting errors

```{r}
var <- 'setting_errors'

# specify model
mdl <- aov_ez(id = 'sub',
              within = c('multi_cond', 'multi_trial'), 
              between = 'train_type',
              dv = 'setting_errors_mean',
              data = avg_multi[ses=='testing'])

# get estimated marginal means from the model
emm_int <- emmeans(mdl, c('multi_cond', 'multi_trial', 'train_type'))

# inspect means
emm_int

# compute contrasts 
(cw1 <- contrast(emm_int, w1))
(cw2 <- contrast(emm_int, w2, adjust='bonferroni'))
(cb <- contrast(emm_int, b))

# plot result
afex_plot(mdl, 
          x = 'multi_cond', 
          trace = 'train_type', 
          panel = 'multi_trial',
          error = "within", 
          data_plot = F) + 
  theme_pubclean()

# save result
dt <- as.data.table(rbind(data.frame(cw1), 
                          data.frame(cw2), 
                          data.frame(cb))) # add new rows as necessary 
dt[, names(.SD) := lapply(.SD, round, 2), .SDcols=c('estimate', 'SE', 'df', 't.ratio')
][, names(.SD) := lapply(.SD, round, 3), .SDcols=c('p.value')]
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(dt, fln)
```

### General errors

```{r}
var <- 'general_errors'

# specify model
mdl <- aov_ez(id = 'sub',
              within = c('multi_cond', 'multi_trial'), 
              between = 'train_type',
              dv = 'general_errors_mean',
              data = avg_multi[ses=='testing'])

# get estimated marginal means from the model
emm_int <- emmeans(mdl, c('multi_cond', 'multi_trial', 'train_type'))

# inspect means
emm_int

# compute contrasts
(cw1 <- contrast(emm_int, w1))
(cw2 <- contrast(emm_int, w2, adjust='bonferroni'))
(cb <- contrast(emm_int, b))

# plot result
afex_plot(mdl, 
          x = 'multi_cond', 
          trace = 'train_type', 
          panel = 'multi_trial',
          error = "within", 
          data_plot = F) + 
  theme_pubclean()

# save result
dt <- as.data.table(rbind(data.frame(cw1), 
                          data.frame(cw2), 
                          data.frame(cb))) # add new rows as necessary 
dt[, names(.SD) := lapply(.SD, round, 2), .SDcols=c('estimate', 'SE', 'df', 't.ratio')
][, names(.SD) := lapply(.SD, round, 3), .SDcols=c('p.value')]
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(dt, fln)
```

### RT first correct

```{r}
var <- 'rt_first_cor'

# specify model
mdl <- aov_ez(id = 'sub',
              within = c('multi_cond', 'multi_trial'), 
              between = 'train_type',
              dv = 'rt_first_correct_mean',
              data = avg_multi[ses=='testing'])

# get estimated marginal means from the model
emm_int <- emmeans(mdl, c('multi_cond', 'multi_trial', 'train_type'))

# inspect means
emm_int

# compute contrasts
(cw1 <- contrast(emm_int, w1))
(cw2 <- contrast(emm_int, w2, adjust='bonferroni'))
(cb <- contrast(emm_int, b))

# plot result
afex_plot(mdl, 
          x = 'multi_cond', 
          trace = 'train_type', 
          panel = 'multi_trial',
          error = "within", 
          data_plot = F) + 
  theme_pubclean()

# save result
dt <- as.data.table(rbind(data.frame(cw1), 
                          data.frame(cw2), 
                          data.frame(cb))) # add new rows as necessary 
dt[, names(.SD) := lapply(.SD, round, 2), .SDcols=c('estimate', 'SE', 'df', 't.ratio')
][, names(.SD) := lapply(.SD, round, 3), .SDcols=c('p.value')]
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(dt, fln)

```

### RT subs correct

```{r}
var <- 'rt_subs_cor'

# specify model
mdl <- aov_ez(id = 'sub',
              within = c('multi_cond', 'multi_trial'), 
              between = 'train_type',
              dv = 'rt_subs_correct_mean',
              data = avg_multi[ses=='testing'])

# get estimated marginal means from the model
emm_int <- emmeans(mdl, c('multi_cond', 'multi_trial', 'train_type'))

# inspect means
emm_int

# compute contrasts
(cw1 <- contrast(emm_int, w1))
(cw2 <- contrast(emm_int, w2, adjust='bonferroni'))
(cb <- contrast(emm_int, b))

# plot result
afex_plot(mdl, 
          x = 'multi_cond', 
          trace = 'train_type', 
          panel = 'multi_trial',
          error = "within", 
          data_plot = F) + 
  theme_pubclean()

# save result
dt <- as.data.table(rbind(data.frame(cw1), 
                          data.frame(cw2), 
                          data.frame(cb))) # add new rows as necessary 
dt[, names(.SD) := lapply(.SD, round, 2), .SDcols=c('estimate', 'SE', 'df', 't.ratio')
][, names(.SD) := lapply(.SD, round, 3), .SDcols=c('p.value')]
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(dt, fln)
```

## Training session

```{r}
ses <- 'train'

## define contrasts for analysis
# effect of train_type
stable_vs_variable <- list(stable_vs_variable = c(1, -1))
```

### Setting errors

```{r}
var <- 'setting_errors'

# specify model
mdl <- aov_ez(id = 'sub',
              # within = '', 
              between = 'train_type',
              dv = 'setting_errors_mean',
              data = avg_multi[ses=='training' & switch=='non-switch',])

# get estimated marginal means from the model
emm_btw <- emmeans(mdl, 'train_type')

# inspect means
emm_btw

# compute contrasts
(cb <- contrast(emm_btw, stable_vs_variable))

# plot result
afex_plot(mdl, 
          x = 'train_type', 
          # trace = '', 
          error = "between", 
          data_plot = F) + 
  theme_pubclean()

# save result
dt <- as.data.table(data.frame(cb)) 
dt[, names(.SD) := lapply(.SD, round, 2), .SDcols=c('estimate', 'SE', 'df', 't.ratio')
][, names(.SD) := lapply(.SD, round, 3), .SDcols=c('p.value')]
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(dt, fln)
```

### General errors

```{r}
var <- 'general_errors'

# specify model
mdl <- aov_ez(id = 'sub',
              # within = '', 
              between = 'train_type',
              dv = 'general_errors_mean',
              data = avg_multi[ses=='training' & switch=='non-switch',])

# get estimated marginal means from the model
emm_btw <- emmeans(mdl, 'train_type')

# inspect means
emm_btw

# compute contrasts
(cb <- contrast(emm_btw, stable_vs_variable))

# plot result
afex_plot(mdl, 
          x = 'train_type', 
          # trace = '', 
          error = "between", 
          data_plot = F) + 
  theme_pubclean()

# save result
dt <- as.data.table(data.frame(cb)) 
dt[, names(.SD) := lapply(.SD, round, 2), .SDcols=c('estimate', 'SE', 'df', 't.ratio')
][, names(.SD) := lapply(.SD, round, 3), .SDcols=c('p.value')]
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(dt, fln)
```

# Working memory task

```{r}
task <- 'wmt'

# change factor level names
avg_multi_mts <- avg_multi_mts[unique(avg_multi[, .(sub, train_type)]), on='sub']
avg_multi_mts[, cond := ifelse(cond=='nc', 'neither', 'other')]
avg_multi_mts[, stage := ifelse(stage=='3', 'testing', 'initial')]
avg_multi_mts[, train_type := ifelse(train_type==1, 'stable', 'variable')]
setnames(avg_multi_mts, 'stage', 'ses') # rename stage to ses 

## define contrasts for analysis
# look at effect of condition at each level of train_type
neither_vs_other <- list(stable = c(1, -1, 0, 0),
                         variable = c(0, 0, 1, -1))
# look at effect of train_type at each level of condition
stable_vs_variable <- list(neither = c(0, 1, 0, -1),
                           other = c(1, 0, -1, 0))
#  interaction effect
interaction <- list(interaction = c(0.5, -0.5, -0.5, 0.5))

```

## Accuracy

```{r}
# assign variable label
var <- 'accuracy'

# specify model
mdl <- aov_ez(id = 'sub',
              within = 'cond', 
              between = 'train_type',
              dv = 'accuracy_mean',
              data = avg_multi_mts[ses=='testing',])

# get estimated marginal means from the model
emm_int <- emmeans(mdl, c('cond', 'train_type'))

# inspect means
emm_int

# compute contrasts
(ci <- contrast(emm_int, interaction))
(cw <- contrast(emm_int, neither_vs_other, adjust='bonferroni'))
(cb <- contrast(emm_int, stable_vs_variable, adjust='bonferroni'))

# plot result
afex_plot(mdl, 
          x = 'cond', 
          trace = 'train_type', 
          error = "within", 
          data_plot = F) + 
  theme_pubclean()

# save result
dt <- as.data.table(rbind(data.frame(ci), 
                          data.frame(cw), 
                          data.frame(cb))) 
dt[, names(.SD) := lapply(.SD, round, 2), .SDcols=c('estimate', 'SE', 'df', 't.ratio')
][, names(.SD) := lapply(.SD, round, 3), .SDcols=c('p.value')]
fln <- str_glue("res/contrasts_exp-{exp}_task-{task}_{var}.csv")
write_csv(dt, fln)
```

## Reaction time

```{r}
# assign variable label
var <- 'rt'

# specify model
mdl <- aov_ez(id = 'sub',
              within = 'cond', 
              between = 'train_type',
              dv = 'rt_mean',
              data = avg_multi_mts[ses=='testing',])

# get estimated marginal means from the model
emm_int <- emmeans(mdl, c('cond', 'train_type'))

# inspect means
emm_int

# compute contrasts
(ci <- contrast(emm_int, interaction))
(cw <- contrast(emm_int, neither_vs_other, adjust='bonferroni'))
(cb <- contrast(emm_int, stable_vs_variable, adjust='bonferroni'))

# plot result
afex_plot(mdl, 
          x = 'cond', 
          trace = 'train_type', 
          error = "within", 
          data_plot = F) + 
  theme_pubclean()

# save result
dt <- as.data.table(rbind(data.frame(ci), 
                          data.frame(cw), 
                          data.frame(cb))) 
dt[, names(.SD) := lapply(.SD, round, 2), .SDcols=c('estimate', 'SE', 'df', 't.ratio')
][, names(.SD) := lapply(.SD, round, 3), .SDcols=c('p.value')]
fln <- str_glue("res/contrasts_exp-{exp}_task-{task}_{var}.csv")
write_csv(dt, fln)
```
