---
title: "Honours Analysis 2025 - Multi-tasking experiment"
format: html
code-fold: true
code-summary: "Show code"
embed-resources: true
editor: visual
execute-dir: project
execute: 
  warning: false
  message: false
---

Load libraries and import data

```{r}
#| output: false

# load libraries
library(afex)
library(emmeans)
library(data.table)
library(ggpubr)
library(tidyverse)
library(stringr)

# set emmeans option to multivariate
afex_options(emmeans_model = "multivariate") # use multivariate for RM designs

# assign experiment label
exp <- 'multi'

# load data
avg_multi <- fread('data/exp-multi_avg.csv')
avg_multi_ss <- fread('data/exp-multi_avg-ss.csv')
avg_multi_mts <- fread('data/exp-multi_mts_avg.csv')

# change factor level names
avg_multi[, switch := ifelse(switch==0, 'non-switch', 'switch')]
avg_multi[, train_type := ifelse(train_type==1,'stable', 'variable')]
avg_multi[, ses := ifelse(ses==2, 'training', 'testing')]

avg_multi_ss[, switch := ifelse(switch==0, 'non-switch', 'switch')]
avg_multi_ss[, train_type := ifelse(train_type==1,'stable', 'variable')]
avg_multi_ss[, ses := ifelse(ses==2, 'training', 'testing')]
avg_multi_ss[, subses := ifelse(subses==1, 'first', 'last')]

avg_multi_mts <- avg_multi_mts[unique(avg_multi[, .(sub, train_type)]), on='sub']
avg_multi_mts[, cond := ifelse(cond=='nc', 'neither', 'other')]
avg_multi_mts[, stage := ifelse(stage=='3', 'testing', 'initial')]
setnames(avg_multi_mts, 'stage', 'ses') 

```

## Testing session

```{r}
# assign session label
ses <- 'test'

```

#### Defining contrasts of interest

Here I define a set of contrasts according to the following procedure/principles:

1.  We have pre-defined hypotheses about specific differences we are interested in
2.  We have collected data using a factorial ANOVA design
3.  Because of #1, we can define a priori contrast vectors we are interested in testing
4.  Because of #2, we can determine that contrast vectors that are orthogonal to each other constitute independent tests. Those that are not orthogonal to each other constitute dependent tests. Thus we group our contrasts into sets. Within a set, contrasts should be non-orthogonal. Across sets, they should be non-orthogonal. This creates our families of tests.
5.  Each family should be controlled at $\alpha$ = .05. If there is only one contrast in the family, then the effect is tested at p=.05. If there is more than one contrast in the family, then we apply a Bonferonni correction to the tests (as the family is a priori defined).

```{r}
#| output: false
# adapting the code above to test the key hypotheses of the study. Under each section of comments, I have built up to the contrast that tests the hypothesis of interest. Then I test for orthogonality, to guide how to control the error rate during hypothesis testing.

ngrps <- 2
n_multi <- 3 # levels of multitasking
n_trial_type <- 2 # levels of search trial type (first vs subsequent)

##### apriori (to apply bonferroni correction on orthogonal sets of contrasts)
# first, we hypothesise that performance should be different on the neither/other trials compared to the none trials, for the first of the search trials
multi_vs_sing_first <- rep(c(1/2, -1, 1/2, 0, 0, 0), times=ngrps)

# next, we hypothesise that the performance difference on other trials should be worse than on neither trials, for the first of the search trials.
multi_neither_vs_other <- rep(c(1, 0, -1, 0, 0, 0), times=ngrps)

# next we predict that this difference on other vs neither trials should be worse for the variable group, compared to the stable group, as the latter group should suffer less cross-task interference 
group <- rep(c(-1, 1), each=n_multi*n_trial_type)
group_by_multi_neither_vs_other <- multi_neither_vs_other * group

# next, we want to know, is the difference between neither/other trials vs none trials, different for first, compared to subsequent search trials? i.e. we predict that the impact of multitasking should reduce from the first to subsequent search trials
first_vs_subs <- rep(c(1, 1, 1, -1, -1, -1), times=ngrps)
multi_vs_sing_both <- rep(c(1/2, -1, 1/2), times=ngrps*n_trial_type)
first_vs_subs_by_multi_vs_sing <- first_vs_subs * multi_vs_sing_both 

# next, we want to know, is the difference between neither than other different for first to subsequent search trials. We predict that any difference should reduce
multi_neither_vs_other_full <- c(1, 0, -1, 1, 0, -1)
first_vs_subs_by_neither_vs_other <- first_vs_subs * multi_neither_vs_other_full



# last, we predict that both of the above effects should be smaller for the variable group compared to the stable group
group_by_first_vs_subs_by_multi_vs_sing <- group * first_vs_subs_by_multi_vs_sing
group_by_first_vs_subs_by_neither_vs_other <- group * first_vs_subs_by_neither_vs_other

# now we have our key contrasts, we can check if they are orthogonal.
# first, I turn them into a matrix
n_contrasts <- 7
all_contrasts <- matrix(c(multi_vs_sing_first, # 1
                          multi_neither_vs_other, # 2
                          group_by_multi_neither_vs_other, # 3 
                          first_vs_subs_by_multi_vs_sing, # 4
                          first_vs_subs_by_neither_vs_other, # 5
                          group_by_first_vs_subs_by_multi_vs_sing, # 6
                          group_by_first_vs_subs_by_neither_vs_other), byrow=FALSE, ncol=n_contrasts)
# compute the gram matrix (i.e. the dot product between all pairs of vectors)
G <- t(all_contrasts) %*% all_contrasts # note that if the vectors are all orthogonal, then the off diagonal enties will be zero, any non-orthognal contrasts will have an off-diagonal element that is different to zero
G # look at G
# I can see that contrasts 1 & 4 are correlated (non-orthogonal) so bonferroni adjustment needs to be applied to these two together, when testing the contrast. 
# 2 & 5 are also non-orthogonal
# 3 & 7 are also non-orthogonal
# The rest are independent to the others so can each be tested at p<.05. So lets define the families now
# I am making the families manually. One day, dream coder Kelly or Caleb will automate this based on the indexes of the off-diagonal elements > 0 :)
fam_multi_vs_sing_first <- list(multi_vs_sing_first = multi_vs_sing_first, # 1
                               first_vs_subs_by_multi_vs_sing = first_vs_subs_by_multi_vs_sing) # 4
                                   
fam_multi_neither_vs_other <- list(multi_neither_vs_other = multi_neither_vs_other, #2
                                   first_vs_subs_by_neither_vs_other = first_vs_subs_by_neither_vs_other) #5

fam_group_w_one_within <- list(group_by_multi_neither_vs_other = group_by_multi_neither_vs_other, # 3
                                           group_by_first_vs_subs_by_neither_vs_other = group_by_first_vs_subs_by_neither_vs_other) # 7

fam_group_by_first_vs_subs_by_multi_vs_sing <- list(group_by_first_vs_subs_by_multi_vs_sing=group_by_first_vs_subs_by_multi_vs_sing) # 6

# note that any tests beyond this point will be post-hoc simple effect comparisons, will be non-orthognal. After each of the above contrast tests, we should determine any post-hoc tests we want to do, which will determine how we control for them.

list_of_contrast_lists <- list(fam_multi_vs_sing_first, 
                               fam_multi_neither_vs_other,
                               fam_group_w_one_within,
                               fam_group_by_first_vs_subs_by_multi_vs_sing)
```

Re-wrote the contrasts above to help me get my head around it - all the vectors it produces are the same as above

```{r}
#| output: false

# convenience vectors
multi_cond <- list(
  neither_other = rep(c(1, 0, -1), times=4),
  none_other = rep(c(0, 1, -1), times=4),
  none_multi = rep(c(0.5, -1, 0.5), times=4)
)
train_type = list(
  int = rep(c(-1, 1), each=6)
)
multi_trial = list(
  int = rep(c(1, -1, 1, -1), each =3),
  first = rep(c(1, 0, 1, 0), each=3)
)

# Note the numbers here are the same as above, but I reordered them in a way that made most sense to me
# 1) Is performance worse on the neither/other (multi) trials compared to the none trials, for the first of the search trials?
none_v_multi_at_fst <- multi_cond$none_multi*multi_trial$first

# 4) Is the difference between neither/other trials vs none trials different for first compared to subsequent search trials? 
none_v_multi_by_trl <- multi_cond$none_multi*multi_trial$int

# 6) Is the effect of trial on the none vs. multi comparison reduced for the variable group compared to the stable group?
none_v_multi_by_trl_by_grp <- none_v_multi_by_trl*train_type$int

# 2) Is performance worse on other trials than neither trials, for the first of the search trials?
neither_v_other_at_fst <- multi_cond$neither_other*multi_trial$first

# 3) Is the difference between other vs neither trials greater for the variable group compared to the stable group?
neither_v_other_at_fst_by_grp <- multi_cond$neither_other*multi_trial$first*train_type$int

# 5) Is the difference between neither and other different for first compared to subsequent search trials?
neither_v_other_by_trl <- multi_cond$neither_other*multi_trial$int

# 7) Is the effect of trial on the neither vs. other comparison reduced for the variable group compared to the stable group?
neither_v_other_by_trl_by_grp <- neither_v_other_by_trl*train_type$int

# now we have our key contrasts, we can check if they are orthogonal.
n_contrasts <- 7
all_contrasts <- matrix(c(none_v_multi_at_fst, 
                          none_v_multi_by_trl, 
                          none_v_multi_by_trl_by_grp, 
                          neither_v_other_at_fst, 
                          neither_v_other_at_fst_by_grp, 
                          neither_v_other_by_trl,
                          neither_v_other_by_trl_by_grp), 
                        byrow=FALSE, 
                        ncol=n_contrasts)
G <- t(all_contrasts) %*% all_contrasts # compute the gram matrix (i.e. the dot product between all pairs of vectors). If the vectors are all orthogonal, then the off diagonal elements will be zero
G # look at G
# 1 & 4 are non-orthogonal
# 2 & 5 are non-orthogonal
# 3 & 7 are non-orthogonal
# Bonferroni adjustment needs to be applied to the pairs of non-orthogonal contrasts. The rest are independent to the others so can each be tested at p<.05. 
# Define the families now
fam_none_v_multi <- list(none_v_multi_at_fst = none_v_multi_at_fst, # 1
                         none_v_multi_by_trl = none_v_multi_by_trl) # 4
                                   
fam_none_v_multi_by_grp <- list(none_v_multi_by_trl_by_grp = none_v_multi_by_trl_by_grp) # 6

fam_neither_vs_other <- list(neither_v_other_at_fst = neither_v_other_at_fst, #2
                             neither_v_other_by_trl = neither_v_other_by_trl) #5

fam_neither_vs_other_by_grp <- list(neither_v_other_at_fst_by_grp = neither_v_other_at_fst_by_grp, # 3
                                    neither_v_other_by_trl_by_grp = neither_v_other_by_trl_by_grp) # 7

# Note that any tests beyond this point will be post-hoc simple effect comparisons, will be non-orthognal. After each of the above contrast tests, we should determine any post-hoc tests we want to do, which will determine how we control for them.


list_of_contrast_lists <- list(fam_none_v_multi, 
                               fam_none_v_multi_by_grp, 
                               fam_neither_vs_other, 
                               fam_neither_vs_other_by_grp)
```

Now I write a function that automatically applies these contrast families to a table of emms, given you have the list of families and the dv.

```{r}
# a function to rule them all
get_all_contrasts <- function(this_dv, list_of_contrast_lists){
  
  # specify model
  mdl <- aov_ez(id = 'sub',
                within = c('multi_cond', 'multi_trial'), 
                between = 'train_type',
                dv = this_dv,
                data = avg_multi[ses=='testing'])
  
  # generate means
  emm_int <- emmeans(mdl, c('multi_cond', 'multi_trial', 'train_type'))
  
    # plot 
  p <- afex_plot(mdl, 
          x = 'multi_cond', 
          trace = 'train_type', 
          panel = 'multi_trial',
          error = "none", 
          data_plot = F) + 
  theme_pubclean()
  
  # compute contrasts
  c <- do.call(rbind, lapply(list_of_contrast_lists, function(x) summary(contrast(emm_int, x, adjust='bonferroni'))))
  
  # put result in data frame
  dt <- data.table(c)
  dt[, names(.SD) := lapply(.SD, round, 2), .SDcols=c('estimate', 'SE', 'df', 't.ratio')
  ][, names(.SD) := lapply(.SD, round, 3), .SDcols=c('p.value')]

  # return output
  return(list(means=emm_int, plot=p, contrasts=c, dt=dt)) #made this return some additional information for interpreting the results
}
```

### Accuracy

```{r}
# assign variable label
var <- 'accuracy_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(res$dt, fln)
```

### Setting errors

```{r}
var <- 'setting_errors_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(res$dt, fln)
```

### General errors

```{r}
var <- 'general_errors_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# post-hoc test to run: none vs. other at first: 
# none_v_other_at_fst <- multi_cond$none_other*multi_trial$first

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(res$dt, fln)
```

### RT first correct

```{r}
var <- 'rt_first_correct_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(res$dt, fln)
```

### RT subs correct

```{r}
var <- 'rt_subs_cor'

# compute contrasts
res <- get_all_contrasts('rt_subs_correct_mean', list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(res$contrasts, fln)
```

## Training session

```{r}
ses <- 'train'
```

Define contrasts for analysis. Copied these from the flexibility experiment - do we need to test for orthogonality in the same was as for the testing session? We didn't do that in the flexibility code

```{r}

# look at effect of sub_ses at each level of train_type
first_vs_last <- list(stable = c(-1, 0, 1, 0),
                      variable = c(0, -1, 0, 1))
# look at effect of train_type at each level of sub_ses
stable_vs_variable <- list(first = c(1, -1, 0, 0),
                           last = c(0, 0, 1, -1))
# interaction effect
interaction <- list(interaction = c(0.5, -0.5, -0.5, 0.5))
# main effect of train_type
train_type <- list(train_type = c(-0.5, 0.5, -0.5, 0.5))

# combine families
list_of_contrast_lists <- list(interaction,
                               first_vs_last, 
                               stable_vs_variable)
```

Edit the contrasts function for the training data

```{r}
# a function to rule them all
get_all_contrasts <- function(this_dv, list_of_contrast_lists){
  
  # specify model
  mdl <- aov_ez(id = 'sub',
                within = 'subses', 
                between = 'train_type',
                dv = this_dv,
                data = avg_multi_ss[ses=='training' & switch=='non-switch'])
  
  # generate means
  emm_int <- emmeans(mdl, c('train_type', 'subses'))
  
    # plot 
  p <- afex_plot(mdl, 
          x = 'subses', 
          trace = 'train_type', 
          error = "none", 
          data_plot = F) + 
  theme_pubclean()
  
  # compute contrasts
  c <- do.call(rbind, lapply(list_of_contrast_lists, function(x) summary(contrast(emm_int, x, adjust='bonferroni'))))
  
  # put result in data frame
  dt <- data.table(c)
  dt[, names(.SD) := lapply(.SD, round, 2), .SDcols=c('estimate', 'SE', 'df', 't.ratio')
  ][, names(.SD) := lapply(.SD, round, 3), .SDcols=c('p.value')]

  # return output
  return(list(means=emm_int, plot=p, contrasts=c, dt=dt))
}

```

### Setting errors

```{r}
# assign variable label
var <- 'setting_errors_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(res$dt, fln)

```

### General errors

```{r}
# assign variable label
var <- 'general_errors_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(res$dt, fln)
```

## Working memory task

```{r}
task <- 'wmt'

```

Define contrasts for analysis

```{r}
#| output: false
# convenience vectors
sess <- list(
  test = rep(c(0, 0, 1, 1), times=2),
  int = rep(c(1, 1, -1, -1), times=2)
)
train_type = list(
  int = rep(c(1, -1), each=4) 
)
cond <- list(
  neither_other = rep(c(1, -1), times=4)
)

# 1) Performance should be worse on 'other' relative to 'neither' trials during the test session
neither_v_other_at_test <- cond$neither_other*sess$test

# 2) The difference in performance on 'other' relative to 'neither' trials should be present at the test session, but not the initial session
neither_v_other_by_ses <- cond$neither_other*sess$int

# 3) Performance on 'other' relative to 'neither' trials should be worse for the variable relative to the stable group at test
neither_v_other_at_test_by_grp <- neither_v_other_at_test*train_type$int

# 4) But there shouls be no difference between groups at the initial session
neither_v_other_by_ses_by_grp <- neither_v_other_by_ses*train_type$int

# test orthogonality
n_contrasts <- 4
all_contrasts <- matrix(c(neither_v_other_at_test,
                          neither_v_other_by_ses,
                          neither_v_other_at_test_by_grp,
                          neither_v_other_by_ses_by_grp), 
                        byrow=FALSE, 
                        ncol=n_contrasts)

G <- t(all_contrasts) %*% all_contrasts
G # 1 & 2 and 3 & 4 are non-orthogonal

# construct families of tests
fam_neither_v_other <- list(neither_v_other_at_test = neither_v_other_at_test,
                            neither_v_other_by_ses = neither_v_other_by_ses)
fam_neither_v_other_by_grp <- list(neither_v_other_at_test_by_grp = neither_v_other_at_test_by_grp,
                                   neither_v_other_by_ses_by_grp = neither_v_other_by_ses_by_grp)

# combine families
list_of_contrast_lists <- list(fam_neither_v_other, 
                               fam_neither_v_other_by_grp)
```

Edit the contrasts function for the training data

```{r}
# a function to rule them all
get_all_contrasts <- function(this_dv, list_of_contrast_lists){
  
  # specify model
  mdl <- aov_ez(id = 'sub',
                within = c('ses', 'cond'), 
                between = 'train_type',
                dv = this_dv,
                data = avg_multi_mts)
  
  # generate means
  emm_int <- emmeans(mdl, c('cond', 'ses', 'train_type'))
  
    # plot 
  p <- afex_plot(mdl, 
          x = 'cond', 
          trace = 'train_type', 
          panel = 'ses',
          error = "none", 
          data_plot = F) + 
  theme_pubclean()
  
  # compute contrasts
  c <- do.call(rbind, lapply(list_of_contrast_lists, function(x) summary(contrast(emm_int, x, adjust='bonferroni'))))
  
  # put result in data frame
  dt <- data.table(c)
  dt[, names(.SD) := lapply(.SD, round, 2), .SDcols=c('estimate', 'SE', 'df', 't.ratio')
  ][, names(.SD) := lapply(.SD, round, 3), .SDcols=c('p.value')]

  # return output
  return(list(means=emm_int, plot=p, contrasts=c, dt=dt))
}

```

## Accuracy

```{r}
# assign variable label
var <- 'accuracy_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_task-{task}_{var}.csv")
write_csv(res$dt, fln)
```

## Reaction time

```{r}
# assign variable label
var <- 'rt_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_task-{task}_{var}.csv")
write_csv(res$dt, fln)
```
