---
title: "Honours Analysis 2025 - Multi-tasking experiment"
format: html
toc: true
toc-title: Contents
toc-location: left
toc-expand: true
code-fold: true
code-summary: "Show code"
embed-resources: true
editor: visual
execute-dir: project
execute: 
  warning: false
  message: false
---

Load libraries, import data, and other housekeeping

```{r}
#| output: false

# required file path diagram
"
.
└── R_project/
    ├── data/
    │   └── ... datafiles go here
    ├── res/
    │   └── ... output goes here
    └── run_analysis_multi_.qmd
"

# set output path
project_path <- getwd()
if (!dir.exists(file.path(project_path, "res"))) {
  dir.create(file.path(project_path, "res"))
}

# load libraries
library(afex)
library(emmeans)
library(data.table)
library(ggpubr)
library(tidyverse)
library(stringr)

# set emmeans option to multivariate
afex_options(emmeans_model = "multivariate") # use multivariate for RM designs

# assign experiment label
exp <- 'multi'

# load data
avg_multi <- fread('data/exp-multi_avg.csv')
avg_multi_subRT <- fread('data/exp-multi_avg_by_subRT.csv', stringsAsFactors = T)
avg_multi_memgrp <- fread('data/exp-multi_avg_by_memgrp.csv', stringsAsFactors = T)
avg_multi_mts <- fread('data/exp-multi_mts_avg.csv')

# change factor level names
avg_multi[, switch := ifelse(switch==0, 'non-switch', 'switch')]
avg_multi[, train_type := ifelse(train_type==1,'stable', 'variable')]
avg_multi[, ses := ifelse(ses==2, 'training', 'testing')]

avg_multi_subRT[, switch := ifelse(switch==0, 'non-switch', 'switch')]
avg_multi_subRT[, train_type := ifelse(train_type==1, 'variable', 'stable')]
avg_multi_subRT[, ses := ifelse(ses==2, 'training', 'testing')]

avg_multi_memgrp[, switch := ifelse(switch==0, 'non-switch', 'switch')]
avg_multi_memgrp[, train_type := ifelse(train_type==1, 'variable', 'stable')]
avg_multi_memgrp[, ses := ifelse(ses==2, 'training', 'testing')]

avg_multi_mts <- avg_multi_mts[unique(avg_multi[, .(sub, train_type)]), on='sub']
avg_multi_mts[, cond := ifelse(cond=='nc', 'neither', 'other')]
avg_multi_mts[, stage := ifelse(stage=='3', 'testing', 'initial')]
setnames(avg_multi_mts, 'stage', 'ses') 
```

## Testing session

#### Defining contrasts of interest

Here I define a set of contrasts according to the following procedure/principles:

1.  We have pre-defined hypotheses about specific differences we are interested in
2.  We have collected data using a factorial ANOVA design
3.  Because of #1, we can define a priori contrast vectors we are interested in testing
4.  Because of #2, we can determine that contrast vectors that are orthogonal to each other constitute independent tests. Those that are not orthogonal to each other constitute dependent tests. Thus we group our contrasts into sets. Within a set, contrasts should be non-orthogonal. Across sets, they should be orthogonal. This creates our families of tests.
5.  Each family should be controlled at $\alpha$ = .05. If there is only one contrast in the family, then the effect is tested at p=.05. If there is more than one contrast in the family, then we apply a Bonferonni correction to the tests (as the family is a priori defined).

```{r}
#| output: false

# assign session label
ses <- 'test'

# convenience vectors
multi_cond <- list(
  neither_other = rep(c(1, 0, -1), times=4),
  none_other = rep(c(0, 1, -1), times=4),
  none_multi = rep(c(0.5, -1, 0.5), times=4)
)
train_type = list(
  int = rep(c(-1, 1), each=6)
)
multi_trial = list( 
  int = rep(c(1, -1, 1, -1), each =3),
  first = rep(c(1, 0, 1, 0), each=3)
)

## A priori contrasts
 
# 1) Is performance worse on the neither/other (multi) trials compared to the none trials, for the first of the search trials?
none_v_multi_at_fst <- multi_cond$none_multi*multi_trial$first

# 2) Is the difference between neither/other trials vs none trials different for first compared to subsequent search trials? 
none_v_multi_by_trl <- multi_cond$none_multi*multi_trial$int

# 3) Is the effect of trial on the none vs. multi comparison reduced for the variable group compared to the stable group?
none_v_multi_by_trl_by_grp <- none_v_multi_by_trl*train_type$int

# 4) Is performance worse on other trials than neither trials, for the first of the search trials?
neither_v_other_at_fst <- multi_cond$neither_other*multi_trial$first

# 5) Is the difference between other vs neither trials greater for the variable group compared to the stable group?
neither_v_other_at_fst_by_grp <- multi_cond$neither_other*multi_trial$first*train_type$int

# 6) Is the difference between neither and other different for first compared to subsequent search trials?
neither_v_other_by_trl <- multi_cond$neither_other*multi_trial$int

# 7) Is the effect of trial on the neither vs. other comparison reduced for the variable group compared to the stable group?
neither_v_other_by_trl_by_grp <- neither_v_other_by_trl*train_type$int

# now we have our key contrasts, we can check if they are orthogonal.
n_contrasts <- 7
all_contrasts <- matrix(c(none_v_multi_at_fst, 
                          none_v_multi_by_trl, 
                          none_v_multi_by_trl_by_grp, 
                          neither_v_other_at_fst, 
                          neither_v_other_at_fst_by_grp, 
                          neither_v_other_by_trl,
                          neither_v_other_by_trl_by_grp), 
                        byrow=FALSE, 
                        ncol=n_contrasts)
G <- t(all_contrasts) %*% all_contrasts # compute the gram matrix (i.e. the dot product between all pairs of vectors). If the vectors are all orthogonal, then the off diagonal elements will be zero
G # look at G
# 1 & 2, 4 & 6, 5 & 7 are non-orthogonal
# Bonferroni adjustment needs to be applied to the pairs of non-orthogonal contrasts. The rest are independent to the others so can each be tested at p<.05. 
# Define the families now
fam_none_v_multi <- list(none_v_multi_at_fst = none_v_multi_at_fst, # 1
                         none_v_multi_by_trl = none_v_multi_by_trl) # 2
                                   
fam_none_v_multi_by_grp <- list(none_v_multi_by_trl_by_grp = none_v_multi_by_trl_by_grp) # 3

fam_neither_vs_other <- list(neither_v_other_at_fst = neither_v_other_at_fst, # 4
                             neither_v_other_by_trl = neither_v_other_by_trl) # 6

fam_neither_vs_other_by_grp <- list(neither_v_other_at_fst_by_grp = neither_v_other_at_fst_by_grp, # 5
                                    neither_v_other_by_trl_by_grp = neither_v_other_by_trl_by_grp) # 7

# Note that any tests beyond this point will be post-hoc simple effect comparisons, will be non-orthognal. After each of the above contrast tests, we should determine any post-hoc tests we want to do, which will determine how we control for them.

list_of_contrast_lists <- list(fam_none_v_multi, 
                               fam_none_v_multi_by_grp, 
                               fam_neither_vs_other, 
                               fam_neither_vs_other_by_grp)
```

Now I write a function that automatically applies these contrast families to a table of emms, given you have the list of families and the dv.

```{r}
# a function to rule them all
get_all_contrasts <- function(this_dv, list_of_contrast_lists){
  
  # specify model
  mdl <- aov_ez(id = 'sub',
                within = c('multi_cond', 'multi_trial'), 
                between = 'train_type',
                dv = this_dv,
                data = avg_multi[ses=='testing'])
  
  # generate means
  emm_int <- emmeans(mdl, c('multi_cond', 'multi_trial', 'train_type'))
  
    # plot 
  p <- afex_plot(mdl, 
          x = 'multi_cond', 
          trace = 'train_type', 
          panel = 'multi_trial',
          error = "none", 
          data_plot = F) + 
  theme_pubclean()
  
  # compute contrasts
  c <- do.call(rbind, lapply(list_of_contrast_lists, function(x) summary(contrast(emm_int, x, adjust='bonferroni'))))
  
  # put result in data frame
  dt <- data.table(c)
  dt[, names(.SD) := lapply(.SD, round, 2), .SDcols=c('estimate', 'SE', 'df', 't.ratio')
  ][, names(.SD) := lapply(.SD, round, 3), .SDcols=c('p.value')]

  # return output
  return(list(means=emm_int, plot=p, contrasts=c, dt=dt)) #made this return some additional information for interpreting the results
}
```

### Accuracy

```{r}
# assign variable label
var <- 'accuracy_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(res$dt, fln)
```

### Setting errors

```{r}
var <- 'setting_errors_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(res$dt, fln)
```

### General errors

```{r}
var <- 'general_errors_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

```

Run post-hoc tests.

```{r}

# 1) From the plot above, the difference between 'none' vs 'multi' appears to be driven by the difference between 'neither' vs 'other' trails. Here we test for non-sig difference between 'none' vs 'other' trials
none_v_other_at_fst <- multi_cond$none_other*multi_trial$first

# 2) Then we repeat the above analysis with the group interaction
none_v_other_at_fst_by_grp <- none_v_other_at_fst*train_type$int

# Check if contrasts are orthogonal
n_contrasts <- 2
all_contrasts <- matrix(c(none_v_other_at_fst,
                          none_v_other_at_fst_by_grp),
                        byrow=FALSE,
                        ncol=n_contrasts)
G <- t(all_contrasts) %*% all_contrasts
#G # look at G - all are orthogonal
fam_none_v_other <- list(none_v_other_at_fst = none_v_other_at_fst) # 1

fam_none_v_other_by_grp <- list(none_v_other_at_fst_by_grp = none_v_other_at_fst_by_grp) # 2

list_of_posthoc_contrast_lists <- list(fam_none_v_other,
                                       fam_none_v_other_by_grp)


# compute post-hoc contrasts
res_ph <- get_all_contrasts(var, list_of_posthoc_contrast_lists)

# show results
res_ph$contrasts

# save results
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(rbind(res$dt, res_ph$dt), fln)

```

### RT first correct

```{r}
var <- 'rt_first_correct_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(res$dt, fln)
```

### RT subs correct

```{r}
var <- 'rt_subs_correct_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(res$contrasts, fln)
```

### RT all

Wrangle data so it's ready for analysis

```{r}
avg_multi_melt <- melt(avg_multi_subRT[ses=='testing'], 
       id.vars=c('sub', 'ses', 'train_type', 'multi_trial'),
       measure.vars=c('rt_first_correct_mean',
                      'rt_subs_correct_1_mean',
                      'rt_subs_correct_2_mean',
                      'rt_subs_correct_3_mean'),
       variable.name='door_selection',
       value.name='rt_correct_mean')

avg_multi_melt <- avg_multi_melt[,.(rt_correct_mean=mean(rt_correct_mean)), by=c('sub', 'train_type', 'multi_trial', 'door_selection')]


```

Define new set of contrasts to compare RTs across clicks

```{r}
#| output: True

# convenience vectors
door_slctn <- list(
  fst_subs = rep(c(-1, 1/3, 1/3, 1/3), times=4),
  sub1_sub2 = rep(c(0, -1, 1, 0), times=4),
  sub1_sub3 = rep(c(0, -1, 0, 1), times=4),
  sub2_sub3 = rep(c(0, 0, -1, 1), times=4)
)
train_type <- list(
  int = rep(c(-1, 1), each=8)
)
multi_trial <- list( 
  int = rep(c(-1, -1, -1, -1, 1, 1, 1, 1), times=2),
  first = rep(c(1, 1, 1, 1, 0, 0, 0, 0), times=2),
  subs = rep(c(0, 0, 0, 0, 1, 1, 1, 1), times=2)
)

## A priori contrasts
 
# 1) Does RT differ on the first click relative to the rest?
fst_v_subs <- door_slctn$fst_subs

# 2) Does #1 differ by multi_trial?
fst_v_subs_by_trl <- fst_v_subs*multi_trial$int

# 3) Does #2 differ by train_type?
fst_v_subs_by_trl_by_grp <- fst_v_subs_by_trl*train_type$int

# 4) Perform pairwise comparisons for subs responses, and test for interaction with multi_trial
sub1_v_sub2 <- door_slctn$sub1_sub2 
sub1_v_sub2_by_trl <- door_slctn$sub1_sub2*multi_trial$int 

sub1_v_sub3 <- door_slctn$sub1_sub3
sub1_v_sub3_by_trl <- door_slctn$sub1_sub3*multi_trial$int 

sub2_v_sub3 <- door_slctn$sub2_sub3
sub2_v_sub3_by_trl <- door_slctn$sub2_sub3*multi_trial$int 

# now we have our key contrasts, we can check if they are orthogonal.
n_contrasts <- 9
all_contrasts <- matrix(c(fst_v_subs, 
                          fst_v_subs_by_trl, 
                          fst_v_subs_by_trl_by_grp, 
                          sub1_v_sub2, 
                          sub1_v_sub2_by_trl,
                          sub1_v_sub3,
                          sub1_v_sub3_by_trl,
                          sub2_v_sub3,
                          sub2_v_sub3_by_trl), 
                        byrow=FALSE, 
                        ncol=n_contrasts)
G <- t(all_contrasts) %*% all_contrasts # compute the gram matrix (i.e. the dot product between all pairs of vectors). If the vectors are all orthogonal, then the off diagonal elements will be zero
G # look at G
# 1, 2, & 3  are non-orthogonal
# 4, 6, & 8 are non-orthogonal
# 5, 7, & 9 are non-orthogonal

fam_fst_v_subs <- list(fst_v_subs = fst_v_subs, # 1 
                       fst_v_subs_by_trl = fst_v_subs_by_trl, # 2 
                       fst_v_subs_by_trl_by_grp = fst_v_subs_by_trl_by_grp) # 3
                                    
fam_subs <- list(sub1_v_sub2 = sub1_v_sub2, # 4
                 sub1_v_sub3 = sub1_v_sub3, # 6
                 sub2_v_sub3 = sub2_v_sub3) # 8

fam_subs_by_trl <- list(sub1_v_sub2_by_trl = sub1_v_sub2_by_trl, # 5
                        sub1_v_sub3_by_trl = sub1_v_sub3_by_trl, # 7
                        sub2_v_sub3_by_trl = sub2_v_sub3_by_trl) # 9


list_of_contrast_lists <- list(fam_fst_v_subs, 
                               fam_subs,
                               fam_subs_by_trl)
```
Edit contrasts function
```{r}
# a function to rule them all
get_all_contrasts <- function(this_dv, list_of_contrast_lists){
  
  # specify model
  mdl <- aov_ez(id = 'sub',
                within = c('multi_trial', 'door_selection'), 
                between = 'train_type',
                dv = this_dv,
                data = avg_multi_melt)
  
  # generate means
  emm_int <- emmeans(mdl, c('door_selection', 'multi_trial', 'train_type'))
  
    # plot 
  p <- afex_plot(mdl, 
          x = 'door_selection', 
          trace = 'train_type', 
          panel = 'multi_trial',
          error = "none", 
          data_plot = F) + 
  theme_pubclean() + 
  theme(axis.text.x = element_text(angle = 90, 
                                   vjust = 0.5, 
                                   hjust=1))
  
  # compute contrasts
  c <- do.call(rbind, lapply(list_of_contrast_lists, function(x) summary(contrast(emm_int, x, adjust='bonferroni'))))
  
  # put result in data frame
  dt <- data.table(c)
  dt[, names(.SD) := lapply(.SD, round, 2), .SDcols=c('estimate', 'SE', 'df', 't.ratio')
  ][, names(.SD) := lapply(.SD, round, 3), .SDcols=c('p.value')]

  # return output
  return(list(means=emm_int, plot=p, contrasts=c, dt=dt))
}


```

Run analysis and save output

```{r}
var <- 'rt_correct_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(res$contrasts, fln)
```

## Test DVs by memory group

Define contrasts

```{r}
#| output: false

# convenience vectors
mem_grp = list(
  int = rep(c(-1, -1, 1, 1), times=2),
  first = rep(c(1, 1, 0, 0), times=2),
  subs = rep(c(0, 0, 1, 1), times=2)
)
train_type = list(
  int = rep(c(-1, 1), each=4)
)
multi_trial = list( 
  int = rep(c(-1, 1), times=4),
  first = rep(c(1, 0), times=4),
  subs = rep(c(0, 1)), times=4
)

## A priori contrasts
 
# 1) Does the effect of multi_trial differ by memory group?
trl_by_grp <- multi_trial$int*mem_grp$int

# 2) Does this differ by train_type (3-way interaction)
trl_by_grp_by_trn <- multi_trial$int*mem_grp$int*train_type$int

# 3) Compare first to subsequent trials for first memory group 
trl_at_fstg <- multi_trial$int*mem_grp$first

# 4) Compare first to subsequent trials for subs memory group 
trl_at_subg <- multi_trial$int*mem_grp$subs

# 5) Compare first to subsequent memory groups for first multi_trial
grp_at_fstt <- mem_grp$int*multi_trial$first

# 6) Compare first to subsequent memory groups for subs multi_trial
grp_at_subt <- mem_grp$int*multi_trial$subs


# now we have our key contrasts, we can check if they are orthogonal.
n_contrasts <- 6
all_contrasts <- matrix(c(trl_by_grp, 
                          trl_by_grp_by_trn, 
                          trl_at_fstg, 
                          trl_at_subg, 
                          grp_at_fstt, 
                          grp_at_subt), 
                        byrow=FALSE, 
                        ncol=n_contrasts)
G <- t(all_contrasts) %*% all_contrasts # compute the gram matrix (i.e. the dot product between all pairs of vectors). If the vectors are all orthogonal, then the off diagonal elements will be zero
G # look at G
# 1, 3, 4, 5 & 6 are non-orthogonal

fam_trl_grp <- list(trl_by_grp = trl_by_grp, #1
                    trl_at_fstg = trl_at_fstg, #3
                    trl_at_subg = trl_at_subg, #4 
                    grp_at_fstt = grp_at_fstt, #5
                    grp_at_subt = grp_at_subt) #6
                                   
fam_trl_grp_by_trn <- list(trl_by_grp_by_trn = trl_by_grp_by_trn) # 2

list_of_contrast_lists <- list(fam_trl_grp, 
                               fam_trl_grp_by_trn)
```

Edit the contrasts function

```{r}
# a function to rule them all

# first edit data frame to average over switch trials, because the aov_ez() 
# function uses case wise deletion. Note: still does case wise deletion 
# for rt_first_correct_mean and rt_subs_correct_mean because some subjects # have missing data there
data <- avg_multi_memgrp[ses=='testing', 
                 .(accuracy_mean=mean(accuracy_mean, na.rm=T),
                   setting_errors_mean=mean(setting_errors_mean, na.rm=T),
                   general_errors_mean=mean(general_errors_mean, na.rm=T),
                   rt_first_correct_mean=mean(rt_first_correct_mean, na.rm=T),
                   rt_subs_correct_mean=mean(rt_subs_correct_mean, na.rm=T)),
                 by=c('train_type', 'multi_trial', 'mem_group', 'sub')]

get_all_contrasts <- function(this_dv, list_of_contrast_lists){
  
  # specify model
  mdl <- aov_ez(id = 'sub',
                within = c('multi_trial', 'mem_group'), 
                between = 'train_type',
                dv = this_dv,
                data = data)
  
  # generate means
  emm_int <- emmeans(mdl, c('multi_trial', 'mem_group', 'train_type'))
  
    # plot 
  p <- afex_plot(mdl, 
          x = 'multi_trial', 
          trace = 'train_type', 
          panel = 'mem_group',
          error = "none", 
          data_plot = F) + 
  theme_pubclean()
  
  # compute contrasts
  c <- do.call(rbind, lapply(list_of_contrast_lists, function(x) summary(contrast(emm_int, x, adjust='bonferroni'))))
  
  # put result in data frame
  dt <- data.table(c)
  dt[, names(.SD) := lapply(.SD, round, 2), .SDcols=c('estimate', 'SE', 'df', 't.ratio')
  ][, names(.SD) := lapply(.SD, round, 3), .SDcols=c('p.value')]

  # return output
  return(list(means=emm_int, plot=p, contrasts=c, dt=dt))
}


```

### Accuracy

```{r}

# assign variable label
var <- 'accuracy_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}_by_memgrp.csv")
write_csv(res$dt, fln)

```
### Setting errors

```{r}

# assign variable label
var <- 'setting_errors_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}_by_memgrp.csv")
write_csv(res$dt, fln)

```

### General errors

```{r}

# assign variable label
var <- 'general_errors_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}_by_memgrp.csv")
write_csv(res$dt, fln)

```

### RT_first_correct

```{r}

# assign variable label
var <- 'rt_first_correct_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}_by_memgrp.csv")
write_csv(res$dt, fln)

```

### RT subs correct

```{r}

# assign variable label
var <- 'rt_subs_correct_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}_by_memgrp.csv")
write_csv(res$dt, fln)

```



## Training session

Define contrasts for training data.

```{r}
ses <- 'train'

# look at main effect of train_type
stable_vs_variable <- list(stable_vs_variable = c(-1, 1))

# combine families
list_of_contrast_lists <- list(stable_vs_variable)
```

Edit the contrasts function.

```{r}
# a function to rule them all
get_all_contrasts <- function(this_dv, list_of_contrast_lists){
  
  # specify model
  mdl <- aov_ez(id = 'sub',
                between = 'train_type',
                dv = this_dv,
                data = avg_multi[ses=='training' & switch=='non-switch'])
  
  # generate means
  emm_int <- emmeans(mdl, 'train_type')
  
    # plot 
  p <- afex_plot(mdl, 
          x = 'train_type', 
          error = "between", 
          data_plot = F) + 
  theme_pubclean()
  
  # compute contrasts
  c <- do.call(rbind, lapply(list_of_contrast_lists, function(x) summary(contrast(emm_int, x, adjust='bonferroni'))))
  
  # put result in data frame
  dt <- data.table(c)
  dt[, names(.SD) := lapply(.SD, round, 2), .SDcols=c('estimate', 'SE', 'df', 't.ratio')
  ][, names(.SD) := lapply(.SD, round, 3), .SDcols=c('p.value')]

  # return output
  return(list(means=emm_int, plot=p, contrasts=c, dt=dt))
}

```

### Accuracy

```{r}

# assign variable label
var <- 'accuracy_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(res$dt, fln)

```

### Setting errors

```{r}

# assign variable label
var <- 'setting_errors_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(res$dt, fln)

```

### General errors

```{r}
# assign variable label
var <- 'general_errors_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_ses-{ses}_{var}.csv")
write_csv(res$dt, fln)
```

## Working memory task

Define contrasts for analysis

```{r}
#| output: false
#| 
task <- 'wmt'

#| output: false
# convenience vectors
sess <- list(
  test = rep(c(0, 0, 1, 1), times=2),
  int = rep(c(1, 1, -1, -1), times=2)
)
train_type = list(
  int = rep(c(1, -1), each=4) 
)
cond <- list(
  neither_other = rep(c(1, -1), times=4)
)

# 1) Performance should be worse on 'other' relative to 'neither' trials during the test session
neither_v_other_at_test <- cond$neither_other*sess$test

# 2) The difference in performance on 'other' relative to 'neither' trials should be present at the test session, but not the initial session
neither_v_other_by_ses <- cond$neither_other*sess$int

# 3) Performance on 'other' relative to 'neither' trials should be worse for the variable relative to the stable group at test
neither_v_other_at_test_by_grp <- neither_v_other_at_test*train_type$int

# 4) But there shouls be no difference between groups at the initial session
neither_v_other_by_ses_by_grp <- neither_v_other_by_ses*train_type$int

# test orthogonality
n_contrasts <- 4
all_contrasts <- matrix(c(neither_v_other_at_test,
                          neither_v_other_by_ses,
                          neither_v_other_at_test_by_grp,
                          neither_v_other_by_ses_by_grp), 
                        byrow=FALSE, 
                        ncol=n_contrasts)

G <- t(all_contrasts) %*% all_contrasts
G # 1 & 2 and 3 & 4 are non-orthogonal

# construct families of tests
fam_neither_v_other <- list(neither_v_other_at_test = neither_v_other_at_test,
                            neither_v_other_by_ses = neither_v_other_by_ses)
fam_neither_v_other_by_grp <- list(neither_v_other_at_test_by_grp = neither_v_other_at_test_by_grp,
                                   neither_v_other_by_ses_by_grp = neither_v_other_by_ses_by_grp)

# combine families
list_of_contrast_lists <- list(fam_neither_v_other, 
                               fam_neither_v_other_by_grp)
```

Edit the contrasts function for the training data

```{r}
# a function to rule them all
get_all_contrasts <- function(this_dv, list_of_contrast_lists){
  
  # specify model
  mdl <- aov_ez(id = 'sub',
                within = c('ses', 'cond'), 
                between = 'train_type',
                dv = this_dv,
                data = avg_multi_mts)
  
  # generate means
  emm_int <- emmeans(mdl, c('cond', 'ses', 'train_type'))
  
    # plot 
  p <- afex_plot(mdl, 
          x = 'cond', 
          trace = 'train_type', 
          panel = 'ses',
          error = "none", 
          data_plot = F) + 
  theme_pubclean()
  
  # compute contrasts
  c <- do.call(rbind, lapply(list_of_contrast_lists, function(x) summary(contrast(emm_int, x, adjust='bonferroni'))))
  
  # put result in data frame
  dt <- data.table(c)
  dt[, names(.SD) := lapply(.SD, round, 2), .SDcols=c('estimate', 'SE', 'df', 't.ratio')
  ][, names(.SD) := lapply(.SD, round, 3), .SDcols=c('p.value')]

  # return output
  return(list(means=emm_int, plot=p, contrasts=c, dt=dt))
}

```

### Accuracy

```{r}
# assign variable label
var <- 'accuracy_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_task-{task}_{var}.csv")
write_csv(res$dt, fln)
```

### Reaction time

```{r}
# assign variable label
var <- 'rt_mean'

# compute contrasts
res <- get_all_contrasts(var, list_of_contrast_lists)

# show results
res$contrasts
res$plot

# save result
fln <- str_glue("res/contrasts_exp-{exp}_task-{task}_{var}.csv")
write_csv(res$dt, fln)
```
